package tools

import (
	"archive/tar"
	"github.com/wal-g/wal-g"
	"io"
	"math/rand"
	"net/http"
	"regexp"
	"strconv"
	"sync/atomic"
)

var counter int32

// StrideByteReader allows for customizable "strides" of
// random bytes. Creates an infinite stream.
type StrideByteReader struct {
	stride    int
	counter   int
	randBytes []byte
}

// NewStrideByteReader creates a new random byte
// stride generator with a seed of 0.
func NewStrideByteReader(s int) *StrideByteReader {
	sb := StrideByteReader{
		stride:    s,
		randBytes: make([]byte, s),
	}

	rand.Seed(0)
	//rand.Seed(time.Now().UTC().UnixNano())
	rand.Read(sb.randBytes)
	return &sb
}

// Read creates randomly generated bytes of 'stride' length.
func (sb *StrideByteReader) Read(p []byte) (int, error) {
	l := len(sb.randBytes)

	n := 0
	for start := 0; start < len(p); n = copy(p[start:], sb.randBytes[sb.counter:]) {
		sb.counter = (sb.counter + n) % l
		start += n
	}

	return len(p), nil
}

// CreateTar creates a new tarball from the passed in reader
// and writes to a destination writer.
func CreateTar(w io.Writer, r *io.LimitedReader) {
	//defer TimeTrack(time.Now(), "CREATE TAR")
	tmp := atomic.AddInt32(&counter, 1)
	_ = tmp
	tw := tar.NewWriter(w)

	hdr := &tar.Header{
		Name: strconv.Itoa(int(counter)),
		Size: int64(r.N),
		Mode: 0600,
	}

	if err := tw.WriteHeader(hdr); err != nil {
		panic(err)
	}

	if _, err := io.Copy(tw, r); err != nil {
		panic(err)
	}

	if err := tw.Close(); err != nil {
		panic(err)
	}

}

// Handler allows for generation of random bytes by configuring
// the URL 'https://localhost:8080/stride-N.bytes-N.tar.lzo' where
// byte size and stride length are customizable.
//
// Compressed tar files are automatically generated. Grab using curl
// ie. 'curl -sk ...'
func Handler(w http.ResponseWriter, r *http.Request) {
	matcher := regexp.MustCompile(`/stride-(\d+).bytes-(\d+).tar(.lzo)?`)
	str := matcher.FindStringSubmatch(r.URL.Path)
	stride, err := strconv.Atoi(str[1])

	if err != nil {
		panic(err)
	}

	nBytes, err := strconv.Atoi(str[2])
	if err != nil {
		panic(err)
	}

	lzoFlag := str[3]

	sb := NewStrideByteReader(stride)
	lr := io.LimitedReader{
		R: sb,
		N: int64(nBytes),
	}

	//defer walg.TimeTrack(time.Now(), "HANDLER")

	switch lzoFlag {
	case "":
		CreateTar(w, &lr)
	case ".lzo":
		pr, pw := io.Pipe()
		lzow := walg.NewLzoWriter(pw)

		go func() {
			CreateTar(lzow, &lr)
			defer lzow.Close()
			defer pw.Close()
		}()

		io.Copy(w, pr)
		if err != nil {
			panic(err)
		}
	default:
		panic("bug")
	}
}
